---
title: "Assessing the 'movescape' of giant armadillos (*Priodontes maximus*)"
author: "Josh Cullen"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  pdf_document: 
    fig_caption: yes
    latex_engine: xelatex
header-includes:
  - \usepackage{float}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      message = FALSE,
                      warning = FALSE,
                      fig.width=6,
                      fig.height = 4,
                      fig.align = 'center',
                      fig.pos = 'H')
```

# Background

Studies have been conducted on the habitat selection of giant armadillos in the Brazilian Pantanal, which is useful to determine which patches are most (or least) suitable for resting and foraging by this species. However, the combination of habitat preference with the speed of giant armadillo movements can help to deduce functional connectivity across the landscape. This is similar to the approach taken by Bastille-Rousseau and Wittemyer (2020) where they characterize a ‘movescape’ (or the functional role of areas for movement across a landscape) using a combination of functional and structural connectivity metrics, as well as intrinsic properties of animal behavior from GPS tracks. We approach the estimation of a ‘movescape’ differently by estimating the time spent per pixel (for a given landscape) and compare these estimates against those of habitat selection. By combining the speed of movement with a measure of habitat selection, we can discriminate between potential corridors of connectivity and high risk areas. Additionally, we can also resolve the difference between patches that provide shelter, protection, or quality forage against areas that impede movement.


# Methods

GPS tracks were available for 7 individuals (blanca, emanuel, gala, mafalda, mazeboti, sara, tex) sampled at 7 min intervals for varying durations from 2019 – 2020. A sample size of N = 9,948 total observations were analyzed from all 7 IDs (the same dataset used for the estimation of behavioral states).\newline

To estimate habitat selection in these armadillos, I fitted a step-selection function (SSF) using the Tasseled Cap Transformations of greenness and wetness to match the covariates used in the comparisons of behavioral states. Greenness is a  measure of vegetation productivity (similar to NDVI), whereas wetness is a measure of moisture (similar to NDWI). Land use/land cover (LU/LC) was not included since the 'Floodable' class would be somewhat redundant with wetness. Additionally, the use of dynamic, continuous variables would be able to account for more nuanced measures of habitat selection and resistance. SSFs were fit separately by ID to account for different functional responses. Greenness and wetness were aggregated into seasonal estimates, which provided a way to account for the dynamic change in wet vs dry areas over time as well as primary productivity. For the SSF, I sampled 30 control points (i.e., available points) for each case point (i.e., used point). Greenness and wetness were extracted from the associated seasonal raster in which the relocation was sampled. Habitat selection surfaces were calculated across individuals to generate seasonal estimates of habitat selection at a population level.\newline

The velocity-based resistance model was estimated where time spent per pixel is a function of each of the covariates included within the SSF (greenness, wetness). Separate models were fit by ID to assess individual heterogeneity (i.e., differences in functional responses). Similar to the steps taken for the SSF, estimates were aggregated across individuals to generate population-level predictions of resistance per season.\newline

Given the estimates of habitat selection and time spent per pixel, we explored the movescape in two different ways: 1) by visualizing the metrics plotted on top of one another using different color ramps and 2) by classifying pixels into different categories. When visualizing a scatterplot of the values of habitat selection against time spent per pixel, this could be broken into quadrants where each quadrant represents a different category of movement. These categories were classified as:

1. Fast-Preferred (e.g., corridors for fast movement)
2. Slow-Preferred (e.g., habitat that is used for resting, foraging, or protection)
3. Fast-Avoided (e.g., easy to move through, but risky/dangerous matrix)
4. Slow-Avoided (e.g., habitat that impedes movement)\newline

These categories will then be mapped onto each pixel of the raster to estimate the movescape of the giant armadillos.\newline



Below, maps are shown for the the dynamic greenness and wetness covariates. Gaps in the Summer rasters are due to clouds and cloud shadows masked from the Landsat 8 imagery from which this metric was derived. This could potentially be resolved later on by using finer spatiotemporal scale Sentinel-2 imagery that may fill in these gaps.

```{r load_data_ssf}

library(tidyverse)
library(lubridate)
library(raster)
library(glmmTMB)
library(lubridate)
library(survival)
library(amt)
library(fishualize)
library(ggnewscale)
library(cowplot)

set.seed(2021)


setwd("~/Documents/Snail Kite Project/Data/R Scripts/acceleration")

dat<- read.csv('Giant Armadillo state estimates.csv', as.is = T)
dat$date<- as_datetime(dat$date, tz = "UTC")
dat<-  dat %>% 
  rename(x = easting, y = northing) %>% 
  mutate(across(c('z.map','z.post.thresh','z.post.max'), factor,
                levels = c("Slow-Turn","Slow-Unif","Exploratory","Transit","Unclassified"))
  )

dat$month<- month.abb[month(dat$date)]
dat$month<- factor(dat$month, levels = month.abb[c(5:12,1)])
dat$season<- ifelse(dat$month %in% c(month.abb[3:5]), "Fall",
                    ifelse(dat$month %in% c(month.abb[6:8]), "Winter",
                           ifelse(dat$month %in% c(month.abb[9:11]), "Spring", "Summer")))
dat$season<- factor(dat$season, levels = c("Fall","Winter","Spring","Summer"))

dat<- dat %>% 
  rename(t = date)  #for amt package


#Tasseled Cap Greenness
green<- brick('GiantArm_tcgreen_season.grd')
green.df<- as.data.frame(green, xy = T)
green.df2<- pivot_longer(green.df, cols = -c(x,y), names_to = "season", values_to = "green")
green.df2$season<- factor(green.df2$season, levels = names(green))

green_s<- green  #for scaled greenness
values(green_s)<- scale(values(green_s))


#Tasseled Cap Wetness
wet<- brick('GiantArm_tcwet_season.grd')
# compareRaster(green, wet)

wet.df<- as.data.frame(wet, xy = T)
wet.df2<- pivot_longer(wet.df, cols = -c(x,y), names_to = "season", values_to = "wet")
wet.df2$season<- factor(wet.df2$season, levels = names(wet))

wet_s<- wet  #for scaled wetness
values(wet_s)<- scale(values(wet_s))


#set times (Z) for dynamic greenness and wetness RasterBricks
green_s<- setZ(green_s, ymd(c("2019-03-01","2019-06-01","2019-09-01","2019-12-01")))
wet_s<- setZ(wet_s, ymd(c("2019-03-01","2019-06-01","2019-09-01","2019-12-01")))


setwd("~/Documents/Snail Kite Project/Data/R Scripts/ValleLabUF/resist_avg")

```

```{r map_environ_covars, fig.cap="Maps of Tasseled Cap greenness and wetness. Higher values indicate greener or wetter habitat, respectively."}

#map TC Greenness
ggplot() +
  geom_raster(data = green.df2, aes(x, y, fill = green)) +
  scale_fill_distiller("Greenness", palette = "Greens", na.value = "transparent",
                       limits = c(-2000,5000), direction = 1) +
  geom_point(data = dat, aes(x, y, color = id), size = 0.25) +
  scale_color_brewer("", palette = "Dark2") +
  scale_x_continuous(expand = c(0,0)) +
  scale_y_continuous(expand = c(0,0)) +
  labs(x="Easting", y="Northing") +
  theme_bw() +
  coord_equal() +
  theme(legend.position = "right",
        axis.title = element_text(size = 18),
        axis.text = element_text(size = 10),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 12),
        strip.text = element_text(size = 12, face = "bold")) +
  facet_wrap(~ season)


#map TC Wetness
ggplot() +
  geom_raster(data = wet.df2, aes(x, y, fill = wet)) +
  scale_fill_distiller("Wetness", palette = "Blues", na.value = "transparent",
                       limits = c(-5000,250), direction = 1) +
  geom_point(data = dat, aes(x, y, color = id), size = 0.25) +
  scale_color_brewer("", palette = "Dark2") +
  scale_x_continuous(expand = c(0,0)) +
  scale_y_continuous(expand = c(0,0)) +
  labs(x="Easting", y="Northing") +
  theme_bw() +
  coord_equal() +
  theme(legend.position = "right",
        axis.title = element_text(size = 18),
        axis.text = element_text(size = 10),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 12),
        strip.text = element_text(size = 12, face = "bold")) +
  facet_wrap(~ season)
```


# Results

## Habitat Selection

The estimated coefficients from the SSF are plotted below and shown on the logit scale from the conditional logistic regression. Overall, there appeared to be a notable level of inter-individual heterogeneity. While most individual-level coefficient estimates were not significant (95% confidence interval included 0), mean estimates showed both positive and negative responses to greenness and wetness. Most IDs tended to exhibit a negative relationship with wetness, although gala and mafalda both exhibited significant positive estimates for wetness. Most estimates for greenness had much wider confidence intervals that included zero, but one individual (mafalda) exhibited a significant negative relationship.

```{r plot_ssf_coeffs, fig.cap="Estimated individual-level coefficients from the SSF. Estimates are on the logit scale."}

soma.betas<- read.csv('SSF coeffs.csv', as.is = T)
soma.betas$coef.names<- factor(soma.betas$coef.names, levels = unique(soma.betas$coef.names))

ggplot(data=soma.betas, aes(x=coef.names, y=coef, ymin=lower, ymax=upper, color = id)) +
  geom_hline(yintercept = 0) +
  geom_errorbar(position = position_dodge(0.55), width = 0, size = 0.75) +
  geom_point(position = position_dodge(0.55), size=2) +
  scale_color_fish_d(option = "Scarus_tricolor") +
  scale_x_discrete(labels = c("Greenness","Wetness")) +
  theme_bw() +
  coord_flip() +
  labs(x="", y="") +
  theme(axis.text = element_text(size = 14),
        panel.grid = element_blank())
```


Spatiotemporal predictions of habitat selection appear to show notable differences across seasons within IDs. At an individual-level, blanca and emanuel did not exhibit strong preference or avoidance of any regions of the landscape. However, gala and mafalda both displayed greater preference for wetter and forested habitats. This may be due to the timing of recorded observations which were almost entirely during the wet season (Fall/Winter). The functional responses of the remaining IDs (mazeboti, sara, tex) appeared to be opposite to that of gala and mafalda. These 3 IDs were recorded in either only the dry season (sara) or in both the wet and dry seasons (mazeboti, tex). Therefore, it appears likely that the responses exhibited by all IDs besides gala and mafalda are more reflective of habitat selection given the different seasons of available data. Therefore, gala and mafalda were removed before calculating population-level averages of habitat selection for each season. These seasonal estimates display the overall negative relationship with wetter habitats and the seasonal dynamics of water across the landscape. No strong patterns associated with greenness are observed, which matches with the coefficient estimates for most individuals.

```{r sample_pts_ssf}
# Modify data into format readable by 'amt'
dat_all <- dat %>% nest(-id) 
dat_all <- dat_all %>% 
  mutate(trk = map(data, function(d) {
    make_track(d, x, y, t, crs = sp::CRS("+init=epsg:32721"))
  }))


# Resample the tracks to 7 minutes with a tolerance of 2 minutes
dat1 <- dat_all %>% 
  mutate(dat_clean = map(trk, ~ {
    .x %>% track_resample(rate = minutes(7), tolerance = seconds(120))
  }))


# Generate available steps for each ID and extract environ covars
dat_ssf <- dat1 %>% 
  mutate(stps = map(dat_clean, ~ .x %>% steps_by_burst() %>% 
                      random_steps(n_control = 30)))

dat_ssf2<- dat_ssf %>% 
  mutate(stps = map(stps, ~.x %>% 
                      extract_covariates_var_time(covariates = green_s,
                                                              when = "after",
                                                              where = "end",
                                                              max_time = days(91),
                                                              name_covar = "green") %>% 
                      extract_covariates_var_time(covariates = wet_s,
                                                  when = "after",
                                                  where = "end",
                                                  max_time = days(91),
                                                  name_covar = "wet")
                    )) %>% 
  select(id, stps) %>% unnest() %>% 
  mutate(
    y = as.numeric(case_),
    id = as.numeric(factor(id)), 
    step_id = paste0(id, step_id_, sep = "-"))


# Remove obs where green is NA
dat_ssf3<- dat_ssf2[-which(is.na(dat_ssf2$green)),]
```


```{r ssf_pred}
### Make spatial predictions from SSF

#extract beta coeffs (mean)
betas<- soma.betas$coef


##Perform raster math using beta coeffs

#Make predictions using posterior mean of betas
ind<- c("green","wet")
xmat<- dat_ssf3 %>% 
  filter(y == 1) %>% 
  dplyr::select(all_of(ind)) %>% 
  data.matrix()

### Calculate Resistance Surface by ID ###

ssfSurf<- vector("list", 4)
names(ssfSurf)<- names(green_s)
id1<- unique(soma.betas$id)

for (j in 1:nlayers(green_s)) {
  # print(names(green_s)[j])
  
  tmp<- list()
  
  cov.mat<- cbind(green = raster::values(green_s[[j]]), wet = raster::values(wet_s[[j]]))
  
  for (i in 1:length(id1)) {
    # print(i)
    
    ssf.res<- green[[1]]
    w.hat<- exp(cov.mat %*% soma.betas[which(soma.betas$id == id1[i]), "coef"])
    raster::values(ssf.res)<- w.hat/(1 + w.hat)
    # resistSurf<- resistSurf * 60  #convert from min to sec
    
    #create as data frame
    ssf.res.df<- as.data.frame(ssf.res, xy=T) %>%
      mutate(id = i)
    names(ssf.res.df)[3]<- "sel"
    
    tmp[[i]]<- ssf.res.df
  }
  
  names(tmp)<- id1
  ssfSurf[[j]]<- tmp
  
}


ssfSurf.df<- map(ssfSurf, ~bind_rows(., .id = "id")) %>%
  bind_rows(., .id = "season")
ssfSurf.df$season<- factor(ssfSurf.df$season, levels = unique(ssfSurf.df$season))
```


```{r map_ssf_IDxSeason, fig.width=10, fig.height=8, fig.cap="Map of individual-level habitat selection predictions across seasons."}

## Selection (by season and ID)
ggplot() +
  geom_raster(data = ssfSurf.df, aes(x, y, fill = sel)) +
  geom_path(data = dat, aes(x, y, group = id), alpha = 0.75, color = "chartreuse") +
  scale_fill_viridis_c("Selection", option = "inferno",
                       na.value = "transparent", limits = c(0,1)) +
  scale_x_continuous(expand = c(0,0)) +
  scale_y_continuous(expand = c(0,0)) +
  labs(x="Easting", y="Northing", title = "Habitat Selection") +
  theme_bw() +
  coord_equal() +
  facet_grid(season ~ id) +
  theme(legend.position = "bottom",
        axis.title = element_text(size = 18),
        axis.text = element_text(size = 10),
        strip.text = element_text(size = 16, face = "bold"),
        plot.title = element_text(size = 22),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 12)) +
  guides(fill = guide_colourbar(barwidth = 30, barheight = 1))
```


```{r agg_by_id}

#calculate mean resistance across IDs
ssf.mean.id<- ssfSurf.df %>% 
  bayesmove::df_to_list(., "season") %>% 
  map(., bayesmove::df_to_list, "id") %>% 
  map_depth(., 2, pluck, "sel")

ssf.mean.id2<- ssf.mean.id %>% 
  map(., bind_cols) %>% 
  map(., dplyr::select, -c(gala, mafalda)) %>%   #omit gala and mafalda
  map(., rowMeans, na.rm = T) %>% 
  unlist()

ssf.mean.id3<- cbind(ssfSurf$Fall$blanca[,c("x","y")], sel = ssf.mean.id2) %>% 
  mutate(season = rep(names(ssf.mean.id), each = ncell(green)), .before = "x") %>% 
  mutate(across(season, factor, levels = names(ssf.mean.id)))
```


```{r map_ssf_ID, fig.width=8, fig.height=6, fig.cap="Aggregated estimates of habitat selection across seasons for each ID."}

## Mean across IDs (where observations recorded)
ggplot() +
  geom_raster(data = ssf.mean.id3, aes(x, y, fill = sel)) +
  geom_path(data = dat, aes(x, y, group = id), alpha = 0.75, color = "chartreuse") +
  scale_fill_viridis_c("Selection", option = "inferno",
                       na.value = "transparent", limits = c(0,1)) +
  scale_x_continuous(expand = c(0,0)) +
  scale_y_continuous(expand = c(0,0)) +
  labs(x="Easting", y="Northing", title = "Habitat Selection") +
  theme_bw() +
  coord_equal() +
  facet_wrap( ~ season, nrow = 2) +
  theme(legend.position = "bottom",
        axis.title = element_text(size = 18),
        axis.text = element_text(size = 10),
        strip.text = element_text(size = 16, face = "bold"),
        plot.title = element_text(size = 22),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 12)) +
  guides(fill = guide_colourbar(barwidth = 30, barheight = 1))
```


## Landscape resistance

Compared to the estimated coefficients from the SSF, responses to greenness and wetness were much more consistent when modeling time in the landscape resistance model. Most individuals exhibited the same type of response for both greenness and wetness, although there were a few instances were other individuals displayed the opposite relationship. The magnitude of these relationships was largely variable among individuals, however.\newline

Plots of resistance for each ID across seasons showed very high levels of variation for blanca and mafalda compared to the other individuals, particularly during the wet season (Fall/Winter). The range in estimates of time per pixel was also much higher in these two individuals compared to the other armadillos. Differences in the range of estimates are denoted by the separate legends for each ID. Similar to the results of the SSF, there appeared to be notable dynamic changes in resistance estimates across seasons, but the direction of this shift varied among IDs. Although the ranges in blanca and mafalda were much higher than the other five individuals, they were included in the population-level averages for each season since their removal resulted in homogeneous predictive surfaces. This is due to the opposite responses to greenness and wetness by the remaining IDs. To resolve some of these potential issues with opposite responses to covariates, our next step to run another model that uses random effects for the intercept and slopes for each ID, which should constrain some of this variability across the population.


```{r load_data_resist}

path<- read.csv('Giant Armadillo Resistance Data.csv', as.is=T)
path$dt<- path$dt/60  #convert to min from sec
path$date<- as_datetime(path$date)


# Filter data for only steps with 5 >= dt >= 9 min
path<- path[path$dt >= 5 & path$dt <= 9 & !is.na(path$dt),]


# Remove state col and rows where is.na(greenness)
path<- path %>% 
  filter(!is.na(green))


# Center and scale covariates 
path<- path %>% 
  mutate(across(elev:wet, scale))




#Load model results
dat.summ<- read.csv("Giant Armadillo Resistance Results.csv", as.is = T)
```


```{r plot_resist_coeffs, fig.cap="Estimated individual-level coefficients for the effects of greenness and wetness on the time spent per pixel of the landscape."}

ggplot(data=dat.summ, aes(x=coeff, y=mean, ymin=lower, ymax=upper, color = id)) +
  geom_hline(yintercept = 0) +
  geom_errorbar(position = position_dodge(0.55), width = 0, size = 0.75) +
  geom_point(position = position_dodge(0.55), size=2) +
  scale_color_fish_d(option = "Scarus_tricolor") +
  scale_x_discrete(labels = c("Greenness", "Wetness")) +
  theme_bw() +
  coord_flip() +
  labs(x="", y="") +
  theme(axis.text = element_text(size = 14),
        panel.grid = element_blank())
```


```{r pred_resist}

## Make spatiotemporal predictions

#extract beta coeffs (mean)
betas<- dat.summ$mean


#Make predictions using posterior mean of betas
ind<- c("green", "wet")
xmat<- data.matrix(path[,ind])


### Calculate Resistance Surface by ID ###

resist.dyn<- list()
id1<- unique(dat.summ$id)

for (j in 1:nlayers(green)) {
  # print(names(green)[j])
  
  tmp<- list()
  
  cov.mat<- cbind(#elev = scale(values(dem)),
                  green = scale(values(green[[j]])),
                  wet = scale(values(wet[[j]])))
  
  for (i in 1:length(id1)) {
    # print(i)
    
    resistSurf<- green[[1]]
    raster::values(resistSurf)<- exp(cov.mat %*% dat.summ[which(dat.summ$id == id1[i]), "mean"])
    # resistSurf<- resistSurf * 60  #convert from min to sec
    
    #create as data frame
    resistSurf.df<- as.data.frame(resistSurf, xy=T) %>%
      mutate(id = i)
    names(resistSurf.df)[3]<- "time"
    
    tmp[[i]]<- resistSurf.df
  }
  
  names(tmp)<- names(sort(table(path$id), decreasing = TRUE))
  resist.dyn[[j]]<- tmp
  names(resist.dyn)[j]<- names(green)[j]
}


resist.dyn.df<- map(resist.dyn, ~bind_rows(., .id = "id")) %>% 
  bind_rows(., .id = "season")
resist.dyn.df$season<- factor(resist.dyn.df$season, levels = names(green))
```


```{r map_resist_IDxSeason, fig.width=7, fig.height=14, fig.cap="Estimates of resistance (time per pixel) are predicted for each individual and season."}

## By ID and season
p.blanca<- ggplot() +
  geom_raster(data = resist.dyn.df %>% filter(id == "blanca"),
              aes(x, y, fill = time)) +
  geom_path(data = dat %>% filter(id == "blanca"),
            aes(x, y, group = id), alpha = 0.5, color = "chartreuse") +
  scale_fill_viridis_c("Time Spent\nper Cell (min)", option = "inferno",
                       na.value = "transparent", limits = c(0,10)) +
  scale_x_continuous(expand = c(0,0)) +
  scale_y_continuous(expand = c(0,0)) +
  labs(x="Easting", y="Northing") +
  theme_bw() +
  coord_equal() +
  theme(legend.position = "right",
        axis.title = element_text(size = 18),
        axis.text = element_text(size = 10),
        strip.text = element_text(size = 16, face = "bold"),
        plot.title = element_text(size = 22),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 12)) +
  facet_grid(id ~ season)



p.emanuel<- ggplot() +
  geom_raster(data = resist.dyn.df %>% filter(id == "emanuel"),
              aes(x, y, fill = time)) +
  geom_path(data = dat %>% filter(id == "emanuel"),
            aes(x, y, group = id), alpha = 0.5, color = "chartreuse") +
  scale_fill_viridis_c("Time Spent\nper Cell (min)", option = "inferno",
                       na.value = "transparent") +
  scale_x_continuous(expand = c(0,0)) +
  scale_y_continuous(expand = c(0,0)) +
  labs(x="Easting", y="Northing") +
  theme_bw() +
  coord_equal() +
  theme(legend.position = "right",
        axis.title = element_text(size = 18),
        axis.text = element_text(size = 10),
        strip.text = element_text(size = 16, face = "bold"),
        plot.title = element_text(size = 22),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 12)) +
  facet_grid(id ~ season)



p.gala<- ggplot() +
  geom_raster(data = resist.dyn.df %>% filter(id == "gala"),
              aes(x, y, fill = time)) +
  geom_path(data = dat %>% filter(id == "gala"),
            aes(x, y, group = id), alpha = 0.5, color = "chartreuse") +
  scale_fill_viridis_c("Time Spent\nper Cell (min)", option = "inferno",
                       na.value = "transparent") +
  scale_x_continuous(expand = c(0,0)) +
  scale_y_continuous(expand = c(0,0)) +
  labs(x="Easting", y="Northing") +
  theme_bw() +
  coord_equal() +
  theme(legend.position = "right",
        axis.title = element_text(size = 18),
        axis.text = element_text(size = 10),
        strip.text = element_text(size = 16, face = "bold"),
        plot.title = element_text(size = 22),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 12)) +
  facet_grid(id ~ season)



p.mafalda<- ggplot() +
  geom_raster(data = resist.dyn.df %>% filter(id == "mafalda"),
              aes(x, y, fill = time)) +
  geom_path(data = dat %>% filter(id == "mafalda"),
            aes(x, y, group = id), alpha = 0.5, color = "chartreuse") +
  scale_fill_viridis_c("Time Spent\nper Cell (min)", option = "inferno",
                       na.value = "transparent", limits = c(0,10)) +
  scale_x_continuous(expand = c(0,0)) +
  scale_y_continuous(expand = c(0,0)) +
  labs(x="Easting", y="Northing") +
  theme_bw() +
  coord_equal() +
  theme(legend.position = "right",
        axis.title = element_text(size = 18),
        axis.text = element_text(size = 10),
        strip.text = element_text(size = 16, face = "bold"),
        plot.title = element_text(size = 22),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 12)) +
  facet_grid(id ~ season)



p.mazeboti<- ggplot() +
  geom_raster(data = resist.dyn.df %>% filter(id == "mazeboti"),
              aes(x, y, fill = time)) +
  geom_path(data = dat %>% filter(id == "mazeboti"),
            aes(x, y, group = id), alpha = 0.5, color = "chartreuse") +
  scale_fill_viridis_c("Time Spent\nper Cell (min)", option = "inferno",
                       na.value = "transparent", limits = c(0,5)) +
  scale_x_continuous(expand = c(0,0)) +
  scale_y_continuous(expand = c(0,0)) +
  labs(x="Easting", y="Northing") +
  theme_bw() +
  coord_equal() +
  theme(legend.position = "right",
        axis.title = element_text(size = 18),
        axis.text = element_text(size = 10),
        strip.text = element_text(size = 16, face = "bold"),
        plot.title = element_text(size = 22),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 12)) +
  facet_grid(id ~ season)



p.sara<- ggplot() +
  geom_raster(data = resist.dyn.df %>% filter(id == "sara"),
              aes(x, y, fill = time)) +
  geom_path(data = dat %>% filter(id == "sara"),
            aes(x, y, group = id), alpha = 0.5, color = "chartreuse") +
  scale_fill_viridis_c("Time Spent\nper Cell (min)", option = "inferno",
                       na.value = "transparent") +
  scale_x_continuous(expand = c(0,0)) +
  scale_y_continuous(expand = c(0,0)) +
  labs(x="Easting", y="Northing") +
  theme_bw() +
  coord_equal() +
  theme(legend.position = "right",
        axis.title = element_text(size = 18),
        axis.text = element_text(size = 10),
        strip.text = element_text(size = 16, face = "bold"),
        plot.title = element_text(size = 22),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 12)) +
  facet_grid(id ~ season)




p.tex<- ggplot() +
  geom_raster(data = resist.dyn.df %>% filter(id == "tex"),
              aes(x, y, fill = time)) +
  geom_path(data = dat %>% filter(id == "tex"),
            aes(x, y, group = id), alpha = 0.5, color = "chartreuse") +
  scale_fill_viridis_c("Time Spent\nper Cell (min)", option = "inferno",
                       na.value = "transparent", limits = c(0,5)) +
  scale_x_continuous(expand = c(0,0)) +
  scale_y_continuous(expand = c(0,0)) +
  labs(x="Easting", y="Northing") +
  theme_bw() +
  coord_equal() +
  theme(legend.position = "right",
        axis.title = element_text(size = 18),
        axis.text = element_text(size = 10),
        strip.text = element_text(size = 16, face = "bold"),
        plot.title = element_text(size = 22),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 12)) +
  facet_grid(id ~ season)


## create composite plot where IDs have separate colorbars
plot_grid(p.blanca, p.emanuel, p.gala, p.mafalda, p.mazeboti, p.sara, p.tex,
          ncol = 1)
```


```{r resist_agg_ID}

#calculate mean resistance across IDs
resist.mean.id<- resist.dyn.df %>% 
  bayesmove::df_to_list(., "season") %>% 
  map(., bayesmove::df_to_list, "id") %>% 
  map_depth(., 2, pluck, "time")

resist.mean.id2<- resist.mean.id %>% 
  map(., bind_cols) %>% 
  # map(., dplyr::select, -c(blanca, mafalda)) %>%   #omit blanca and mafalda
  map(., rowMeans, na.rm = T) %>% 
  unlist()

resist.mean.id3<- cbind(resist.dyn$Fall$gala[,c("x","y")], time = resist.mean.id2) %>% 
  mutate(season = rep(names(resist.mean.id), each = ncell(green)), .before = "x") %>% 
  mutate(across(season, factor, levels = names(resist.mean.id)))
```


```{r map_resist_ID, fig.width=8, fig.height=6, fig.cap="Mean resistance across IDs per season."}

## Mean across IDs
ggplot() +
  geom_raster(data = resist.mean.id3, aes(x, y, fill = time)) +
  geom_path(data = dat, aes(x, y, group = id), alpha = 0.5, color = "chartreuse") +
  scale_fill_viridis_c("Time Spent\nper Cell (min)", option = "inferno",
                       na.value = "transparent", limits = c(0,7)) +
  scale_x_continuous(expand = c(0,0)) +
  scale_y_continuous(expand = c(0,0)) +
  labs(x="Easting", y="Northing", title = "Resistance Surface") +
  theme_bw() +
  coord_equal() +
  theme(legend.position = "bottom",
        axis.title = element_text(size = 18),
        axis.text = element_text(size = 10),
        strip.text = element_text(size = 16, face = "bold"),
        plot.title = element_text(size = 22),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 12)) +
  guides(fill = guide_colourbar(barwidth = 30, barheight = 1)) +
  facet_wrap(~ season, nrow = 2)

```


## Integration of speed and habitat selection for movescape

Once estimates of armadillo speed and habitat selection were calculated, these were combined to make inference on the ‘movescape’. Due to the large number of points to plot into each of the quadrants, these are omitted from the report for now. However, these quadrants represent each of the four previously mentioned categories of functional connectivity classifications. From this set of quadrants, points (i.e., pixels) are re-classified based on the quadrant in which it falls and then mapped back onto the landscape. Alternatively, they were also plotted using two different monochromatic palettes that were blended together for a more nuanced interpretation.\newline

Since the estimates for resistance were very right-skewed, the 99.9^th^ quantile of time spent per pixel (1.5 min) was used as a threshold to define the range of times on which to define the quadrant and classify each of the pixels.


```{r load_movescape_results}

dat.comp<- cbind(ssf.mean.id3, time = resist.mean.id3$time)

quant_99.9<- quantile(na.omit(dat.comp$time), 0.999)
dat.comp2<- dat.comp %>% 
  filter(time <= quant_99.9)
time.mid<- (max(dat.comp2$time, na.rm = T) + min(dat.comp2$time, na.rm = T))/2

```


```{r plot_trends_greenwet, fig.cap="Relationship between habitat preference and resistance as related to greenness and wetness."}

## Using 2 continuous color scales
ggplot() +
  geom_raster(data = dat.comp, aes(x, y, fill = time), alpha = 0.75) +
  scale_fill_gradient("Time Spent\nper Cell (min)", low = "white", high = "royalblue3",
                       na.value = "transparent", limits = c(0,quant_99.9)) +
  new_scale_fill() +
  geom_raster(data = dat.comp, aes(x, y, fill = sel), alpha = 0.75) +
  scale_fill_gradient("Selection", low = "red4", high = "white",
                       na.value = "transparent", limits = c(0,1)) +
  geom_path(data = dat, aes(x, y, group = id), alpha = 0.5, color = "black") +
  scale_x_continuous(expand = c(0,0)) +
  scale_y_continuous(expand = c(0,0)) +
  labs(x="Easting", y="Northing") +
  theme_bw() +
  coord_equal() +
  theme(legend.position = "right",
        axis.title = element_text(size = 18),
        axis.text = element_text(size = 10),
        strip.text = element_text(size = 16, face = "bold"),
        plot.title = element_text(size = 22),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 12))  +
  facet_wrap(~ season)


## Creation of 4 classes

all.dat<- dat.comp %>% 
  mutate(fun_class = case_when(.$time > time.mid & .$sel > 0.5 ~ "Slow-Preferred",
                                .$time > time.mid & .$sel < 0.5 ~ "Slow-Avoided",
                                .$time < time.mid & .$sel > 0.5 ~ "Fast-Preferred",
                                .$time < time.mid & .$sel < 0.5 ~ "Fast-Avoided"))



ggplot() +
  geom_raster(data = all.dat, aes(x, y, fill = fun_class), na.rm = T) +
  scale_fill_manual("", values = c("firebrick","forestgreen","yellow","steelblue1"),
                    na.translate = F) +
  geom_path(data = dat, aes(x, y, group = id), alpha = 0.85, color = "black") +
  scale_x_continuous(expand = c(0,0)) +
  scale_y_continuous(expand = c(0,0)) +
  labs(x="Easting", y="Northing") +
  theme_bw() +
  coord_equal() +
  theme(legend.position = "right",
        axis.title = element_text(size = 18),
        axis.text = element_text(size = 10),
        strip.text = element_text(size = 16, face = "bold"),
        plot.title = element_text(size = 22),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 12)) +
  facet_wrap(~ season, nrow = 2)

```


The movescape using the continuous color ramps appears a little more difficult to interpret, primarily because there is not a large range of values estimated for habitat selection. Additionally, the right-skewed estimates of time spent per cell tends to only emphasize the areas that are much slower than the majority of estimates. The other map that classifies pixels into discrete groups is outwardly much easier to interpret, but should be interpreted cautiously since the thresholds for defining these categories was based on the lower 99.9% of estimates for resistance ($t < 1.51$ min). From this discrete map, it appears that the wettest areas are classified as "Slow-Avoided", which primarily occur along what appears to be a seasonal river running through the landscape. Nearby areas that may experience some seasonal flooding were classified as "Fast-Avoided". Most of the remaining regions with higher levels of greenness were classified as "Fast-Preferred", while few small pockets of areas were categorized as "Slow-Preferred". These classifications should be explored further and additional covariates may be added to both the SSF and resistance model as deemed necessary.


# Discussion

While these results do appear to provide a simple way to understand movements of giant armadillos, they would likely be improved by making some modifications in the methods to account for the relatively high level of individual heterogeneity when estimating the ‘movescape’. This may involve fitting using spatial weighting procedures to reduce spurious extrapolations of resistance and habitat selection to pixels never visited by any of the armadillos. This could potentially be performed similarly to methods applied in Osipova et al. (2019) and Zeller et al. (2019) where pixel values are weighted based on the geographic location of each ID. Additionally, the inclusion of a greater number of individuals sampled at other locations and seasons throughout the study region is also likely to improve the inferences made. The estimates of Tasseled Cap greenness and wetness could also potentially be improved by using Sentinel-2 satellite imagery as opposed to Landsat 8 since Sentinel-2 captures images at a 10m (vs a 30 m) spatial resolution and at a 5 day (vs a 16 day) resolution. This would result in fewer images with cloud cover that could be used to calculate seasonal band values, which would likely fill in the gaps in the estimates of summer greenness and wetness. These steps and others (e.g., multi-scale analyses) can be taken to improve these results to estimate dynamic landscape connectivity in giant armadillos.


# References

Bastille‐Rousseau, G., & Wittemyer, G. (2020). Characterizing the landscape of movement to identify critical wildlife habitat and corridors. *Conservation Biology*.

Osipova, L., Okello, M. M., Njumbi, S. J., Ngene, S., Western, D., Hayward, M. W., & Balkenhol, N. (2019). Using step‐selection functions to model landscape connectivity for African elephants: accounting for variability across individuals and seasons. *Animal Conservation*, 22(1), 35-48.

Zeller, K. A., Wattles, D. W., Conlee, L., & DeStefano, S. (2019). Black bears alter movements in response to anthropogenic features with time of day and season. *Movement Ecology*, 7(1), 19.
